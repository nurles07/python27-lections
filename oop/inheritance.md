# наследование
> принцип ООП, где мы можем унаследовать, перепроделять и использовать все аттрибуты 
и методы родительского класса
```py
class A:
    def method(self):
        print("Метод в классе А")

obj_a = A() 
obj_a.method()       
# Метод в классе А

class B(A):
    pass

obj_b = B()
obj_b.method()
# Метод в классе А
```

> класс А - родительский
> класс B - дочерний 

## Переопределение 
> когда мы создаем метод или аттрибут с таким же названием, как и в родительских классах


```py
class C(A):
    def method(self):
        print("Метод в классе С")

obj_c = C()
obj_c.method()
# Метод в классе С
```
## Виды наследования
* **одиночное** (когда один родитель )
* **множественнное** (когда несколько родителей)
* многоуровневое (когда у родителя есть родитель)
* иерархическое (когда у каждого есть только один родитель,но у родителя может быть много детей)
* гибридное (совмещегие разных видов наследования)

## Проблемы множественного наследование
1. Проблема ромба (решение с помощю MRO (с версии 2.6))
> MRO - method resolution order (простраивает порядок для поиска аттрибутов)

```py
class A:
    pass
class B:
    pass
class C(A,B):
    pass

# до MRO
[C, A, object, C, B, object]

# до MRO
[C, A, object, C, B, object]

# после MRO
[C, A, B, object]
```

2. Проблема перекрестного наследования (не решенная, возникает когда невозможно построить приоритет родителей)

```py
# Перекрестное наследование
class A:
    pass

class B:
    pass

class C(A,B):
    pass

class D(B,A):
    pass

class E(C,D):
    pass

# TypeError: Cannot create a consistent method resolution
# order (MRO) for bases A, B
```